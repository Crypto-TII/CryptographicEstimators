# ****************************************************************************
# Copyright 2023 Technology Innovation Institute
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
# ****************************************************************************


from cryptographic_estimators.MQEstimator.series.nmonomial import NMonomialSeries
from math import log2, comb as binomial
from cryptographic_estimators.helper import is_prime_power


def ngates(q, n, theta=2):
    """Returns the number of gates for the given number of multiplications in a finite field.

    Args:
        q (int): The order of the finite field.
        n (int): The number of multiplications (logarithmic).
        theta (int): The exponent of the conversion factor (default: 2).

    Examples:
        >>> from cryptographic_estimators.MQEstimator.mq_helper import ngates
        >>> ngates(16, 16)
        20.0

    Tests:
        >>> ngates(6, 2**16)
        Traceback (most recent call last):
        ...
        ValueError: q must be a prime power
    """
    if not is_prime_power(q):
        raise ValueError("q must be a prime power")
    if theta is None:
        return n + log2(2 * log2(q) ** 2 + log2(q))
    else:
        return n + log2(log2(q)) * theta


def nmonomials_of_degree(d, n, q=None):
    """Returns the number of n-variables monomials of degree d.

    Note:
        If q is provided, then it considers the monomials in a ring modulo the ideal generated by the field equations.
    Args:
        d (int): The degree.
        n (int): The number of variables.
        q (int, optional): The order of the finite field.

    Examples:
        >>> from cryptographic_estimators.MQEstimator.mq_helper import nmonomials_of_degree
        >>> nmonomials_of_degree(d=2, n=10, q=2)
        45
    """
    series = NMonomialSeries(n, q, max_prec=d + 1)
    return series.nmonomials_of_degree(d)

def nmonomials_up_to_degree(d, n, q=None):
    """
    Return the number of n-variables monomials up to degree d.

    Note:
        If q is provided, then it considers the monomials in a ring modulo the ideal generated by the field equations.

    Args:
        d (int): Degree.
        n (int): Number of variables.
        q (int, optional): Order of finite field.

    Examples:
        >>> from cryptographic_estimators.MQEstimator.mq_helper import nmonomials_up_to_degree
        >>> nmonomials_up_to_degree(d=2, n=10, q=2)
        56
    """
    series = NMonomialSeries(n, q, max_prec=d + 1)
    return series.nmonomials_up_to_degree(d)


def sum_of_binomial_coefficients(n, l):
    """
    Calculates the sum of binomial coefficients from 0 to l for the given n.

    Args:
        n (int): A non-negative integer.
        l (int): A non-negative integer.

    Returns:
        int: The sum of the binomial coefficients from 0 to l for the given n.

    Examples:
        >>> from cryptographic_estimators.MQEstimator.mq_helper import sum_of_binomial_coefficients
        >>> sum_of_binomial_coefficients(5, 2)
        16
    """
    if l < 0:
        raise ValueError("l must be a non-negative integer")
    return sum(binomial(n, j) for j in range(l + 1))
