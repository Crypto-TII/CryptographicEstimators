# *****************************************************************************
# Multivariate Quadratic (MQ) Estimator
# Copyright (C) 2021-2022 Emanuele Bellini, Rusydi H. Makarim, Javier Verbel
# Cryptography Research Centre, Technology Innovation Institute LLC
#
# This file is part of MQ Estimator
#
# MQ Estimator is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# MQ Estimator is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# MQ Estimator. If not, see <https://www.gnu.org/licenses/>.
# *****************************************************************************


from sage.arith.misc import is_prime_power
from sage.functions.log import log
from sage.functions.other import ceil
from sage.groups.affine_gps.affine_group import AffineGroup
from sage.rings.finite_rings.finite_field_base import is_FiniteField
from sage.functions.other import binomial
from .series.nmonomial import NMonomialSeries


def ngates(q, n, theta=0):
    """
    Return the number of gates for the given number of multiplications in a finite field

    INPUT:

    - ``q`` -- order of the finite field
    - ``n`` -- no. of multiplications
    - ``theta`` -- exponent of the conversion factor

    EXAMPLES::

        sage: from mpkc.utils import ngates
        sage: ngates(16, 2**16)
        2359296

    TESTS::

        sage: ngates(6, 2**16)
        Traceback (most recent call last):
        ...
        ValueError: q must be a prime power
    """
    if not is_prime_power(q):
        raise ValueError("q must be a prime power")
    if theta:
        return n * log(q, 2) ** theta
    else:
        return n * (2 * log(q, 2) ** 2 + log(q, 2))


def nbits(q, n):
    """
    Return the number of bits required to store `n` elements of a finite field

    - ``q`` -- order of the finite field
    - ``n`` -- no. of field elements

    EXAMPLES::

        sage: from mpkc.utils import nbits
        sage: nbits(4, 256)
        512
    """
    return ceil(log(q, 2)) * n


def nmonomials_of_degree(d, n, q=None):
    """
    Return the number of `n`-variables monomials of degree `d`

    .. NOTE::

        If `q` is provided, then it considers the monomials in a ring modulo the ideal generated by the field equations

    INPUT:

    - ``d`` -- degree
    - ``n`` -- no. of variables
    - ``q`` -- order of finite field (default: None)

    EXAMPLES::

        sage: from mpkc.utils import nmonomials_of_degree
        sage: nmonomials_of_degree(d=2, n=10)
        55
        sage: nmonomials_of_degree(d=2, n=10, q=2)
        45
    """
    series = NMonomialSeries(n, q, max_prec=d+1)
    return series.nmonomials_of_degree(d)


def nmonomials_up_to_degree(d, n, q=None):
    """
    Return the number of `n`-variables monomials up to degree `d`

    .. NOTE::

        If `q` is provided, then it considers the monomials in a ring modulo the ideal generated by the field equations

    INPUT:

    - ``d`` -- degree
    - ``n`` -- no. of variables
    - ``q`` -- order of finite field (default: None)

    EXAMPLES::

        sage: from mpkc.utils import nmonomials_up_to_degree
        sage: nmonomials_up_to_degree(d=2, n=10)
        66
        sage: nmonomials_up_to_degree(d=2, n=10, q=2)
        56
    """
    series = NMonomialSeries(n, q, max_prec=d+1)
    return series.nmonomials_up_to_degree(d)


def random_affine_map(base_field, nvars):
    """
    Return a random invertible affine map

    TESTS::

        sage: from mpkc.utils import random_affine_map
        sage: M, v = random_affine_map(GF(3), 4)
        sage: M.base_ring()
        Finite Field of size 3
        sage: M.is_invertible()
        True
        sage: M.dimensions()
        (4, 4)
        sage: v.base_ring()
        Finite Field of size 3
        sage: v.length()
        4
    """
    if not is_FiniteField(base_field):
        raise TypeError("base_field must be an instance of sage FiniteField")

    if nvars < 1:
        raise ValueError("nvars must be >= 1")

    affine_map = AffineGroup(nvars, base_field).random_element()
    matrix_ = affine_map.A()
    vector_ = affine_map.b()

    return matrix_, vector_


def truncate(x, precision):
    """
    Truncates a float

    INPUT:

    - ``x`` -- value to be truncated
    - ``precision`` -- number of decimal places to after which the ``x`` is truncated

    EXAMPLES::

        sage: from mpkc.utils import truncate
        sage: truncate(3.2030404, 3)
        3.203
    """
    return float(int(x * 10 ** precision) / 10 ** precision)


def sum_of_binomial_coefficients(n, l):
    r"""
    Return the `\sum_{j=0}^{l} \binom{n}{j}`

    INPUT:

    - ``n`` -- a non-negative integer
    - ``l`` -- a non-negative integer

    EXAMPLES::

        sage: from mpkc.utils import sum_of_binomial_coefficients
        sage: sum_of_binomial_coefficients(5, 2)
        16
    """
    if l < 0:
        raise ValueError('l must be a non-negative integer')
    return sum(binomial(n, j) for j in range(l + 1))
